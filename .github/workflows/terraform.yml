name: 'Terraform'

on:
  push:
    branches: [ "master" ]
  pull_request:

permissions:
  contents: read

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v4

    #zips Lambda_code
    - name: zip
      uses: vimtor/action-zip@v1.2
      with:
        files: lambda_code/
        dest: lambda_code.zip
    - name: Move zip
      run: cp lambda_code.zip ./Infra
    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      working-directory: ./Infra
      run: terraform init
    
    - name: Terraform Apply Vpc
      working-directory: ./Infra
      run: terraform apply -target=module.vpc -auto-approve -input=false
    - name: Terraform Apply EKS
      working-directory: ./Infra
      run: terraform apply -target=module.eks -auto-approve -input=false
    
    # Generates an execution plan for Terraform
    - name: Terraform Plan
      working-directory: ./Infra
      run: terraform plan -input=false

      # On push to "master", build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      working-directory: ./Infra
      run: terraform apply -auto-approve -input=false
    
    - name: Export Terraform Outputs to GitHub Environment
      run: |
        {
          echo "sqs_url<<EOF"
          terraform -chdir=Infra output -raw sqs_queue_url
          echo "EOF"
        } >> $GITHUB_ENV

        {
          echo "iam_role_arn<<EOF"
          terraform -chdir=Infra output -raw keda_sqs_role_arn
          echo "EOF"
        } >> $GITHUB_ENV

    - name: Update YAMLs
      run: |
          SQS_URL=$(echo "${{ env.sqs_url }}" | tr -d '\n')
          ROLE_ARN=$(echo "${{ env.iam_role_arn }}" | tr -d '\n')

          sed -i 's|<QUEUE_URL>|'"${SQS_URL}"'|g' Infra/k8s/scaledobjects.yaml
          sed -i 's|<ROLE_ARN>|'"${ROLE_ARN}"'|g' Infra/k8s/serviceaccount.yaml

  Kubernetes:
    needs: terraform

    name: 'Setup Kubernetes'
    runs-on: ubuntu-latest
    environment: production
    defaults:
      run:
        shell: bash
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-southeast-2
      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.31.0
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ap-southeast-2 --name Licence_Plate_Cluster
      - name: Apply Kubernetes resources
        run: |
          kubectl apply --validate=false -f Infra/k8s/serviceaccount.yaml
          kubectl apply --validate=false -f Infra/k8s/deployment.yaml
          kubectl apply --validate=false -f Infra/k8s/scaledobjects.yaml
         